// Generated by CoffeeScript 1.12.7
var Str,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Str = require('../../lib.js.generic/dist/Str');

module.exports.UpdateCategoryTree = (function() {
  UpdateCategoryTree.REQUIRES_GM = false;

  function UpdateCategoryTree(WM) {
    this.WM = WM;
    this.checkWrite = bind(this.checkWrite, this);
    this.writeToC = bind(this.writeToC, this);
    this.createCatLink = bind(this.createCatLink, this);
    this.processCategoryEnd = bind(this.processCategoryEnd, this);
    this.processCategoryAddSuffix = bind(this.processCategoryAddSuffix, this);
    this.processCategory = bind(this.processCategory, this);
    this.storeAlternativeNames = bind(this.storeAlternativeNames, this);
    this.processToC = bind(this.processToC, this);
    this.readToC = bind(this.readToC, this);
    this.mainContinue = bind(this.mainContinue, this);
  }

  UpdateCategoryTree.prototype.main = function(args, callNext) {
    var inparams, params, showRootAlsoIn, summary;
    inparams = args[0];
    summary = args[1];
    if (args[2] != null) {
      showRootAlsoIn = args[2];
    } else {
      showRootAlsoIn = false;
      this.WM.Log.logInfo("The configuration does not specify the " + "showRootAlsoIn value, defaulting to false");
    }
    if (inparams.constructor === Array) {
      if (inparams[0] === "ArchWiki") {
        params = this.WM.ArchWiki.getTableOfContents(inparams[1]);
      } else {
        this.WM.Log.logError("Unrecognized parameter");
        return false;
      }
    } else {
      params = inparams;
    }
    return this.WM.MW.isUserBot(this.mainContinue, [params, showRootAlsoIn, summary, callNext]);
  };

  UpdateCategoryTree.prototype.mainContinue = function(botTest, args) {
    return this.readToC({
      params: args[0],
      minInterval: botTest ? 60000 : 21600000,
      edittoken: "",
      timestamp: "",
      source: "",
      startId: 0,
      endId: 0,
      treeText: "",
      startMark: "START AUTO TOC - DO NOT REMOVE OR MODIFY THIS MARK-->",
      endMark: "<!--END AUTO TOC - DO NOT REMOVE OR MODIFY THIS MARK",
      altNames: {},
      showRootAlsoIn: args[1],
      summary: args[2],
      callNext: args[3]
    });
  };

  UpdateCategoryTree.prototype.readToC = function(args) {
    this.WM.Log.logInfo('Updating ' + this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + " ...");
    return this.WM.MW.callQueryEdit(args.params.page, this.processToC, args);
  };

  UpdateCategoryTree.prototype.processToC = function(title, source, timestamp, edittoken, args) {
    var end, msTimestamp, now, start;
    args.source = source;
    args.timestamp = timestamp;
    args.edittoken = edittoken;
    now = new Date();
    msTimestamp = Date.parse(args.timestamp);
    if (now.getTime() - msTimestamp >= args.minInterval) {
      start = args.source.indexOf(args.startMark);
      end = args.source.lastIndexOf(args.endMark);
      if (start > -1 && end > -1) {
        args.startId = start + args.startMark.length;
        args.endId = end;
        args.treeText = "";
        args.altNames = args.params.keepAltName ? this.storeAlternativeNames(args.source) : {};
        return this.WM.Cat.recurseTree({
          node: args.params.root,
          callNode: this.processCategory,
          callEnd: this.writeToC,
          callArgs: args
        });
      } else {
        this.WM.Log.logError("Cannot find insertion marks in " + this.WM.Log.linkToWikiPage(args.params.page, args.params.page));
        if (args.callNext) {
          return args.callNext();
        }
      }
    } else {
      this.WM.Log.logWarning(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' has been updated too recently');
      if (args.callNext) {
        return args.callNext();
      }
    }
  };

  UpdateCategoryTree.prototype.storeAlternativeNames = function(source) {
    var dict, match, regExp;
    dict = {};
    regExp = /\[\[\:([Cc]ategory\:.+?)\|(.+?)\]\]/gm;
    while (true) {
      match = regExp.exec(source);
      if (match) {
        dict[match[1].toLowerCase()] = match[2];
      } else {
        break;
      }
    }
    return dict;
  };

  UpdateCategoryTree.prototype.processCategory = function(params) {
    var altName, args, indices, j, node, ref, text;
    args = params.callArgs;
    this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(params.node, params.node) + " ...");
    text = "";
    for (j = 0, ref = params.ancestors.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
      text += args.params.indentType;
    }
    if (args.params.showIndices) {
      indices = [];
      node = params;
      while (node.parentIndex !== null) {
        indices.push(node.siblingIndex + 1);
        node = params.nodesList[node.parentIndex];
      }
      if (indices.length) {
        text += "<small>" + indices.reverse().join(".") + ".</small> ";
      }
    }
    altName = args.altNames[params.node.toLowerCase()] ? args.altNames[params.node.toLowerCase()] : null;
    text += this.createCatLink(params.node, args.params.replace, altName);
    text += args.params.rightToLeft ? "&lrm; " : " ";
    if (params.children === "loop") {
      text += "'''[LOOP]'''\n";
      this.WM.Log.logWarning("Loop in " + this.WM.Log.linkToWikiPage(params.node, params.node));
      return this.processCategoryEnd(params, args, text);
    } else {
      return this.WM.Cat.getParentsAndInfo(params.node, this.processCategoryAddSuffix, [params, args, text, altName]);
    }
  };

  UpdateCategoryTree.prototype.processCategoryAddSuffix = function(parents, info, args_) {
    var alsoParents, altName, args, currParent, i, j, k, len, len1, par, params, parentTitles, text;
    params = args_[0];
    args = args_[1];
    text = args_[2];
    altName = args_[3];
    currParent = params.ancestors[params.ancestors.length - 1];
    alsoParents = [];
    text += "<small>(" + (info ? info.pages : 0) + ")";
    if (currParent || args.showRootAlsoIn) {
      for (j = 0, len = parents.length; j < len; j++) {
        par = parents[j];
        if (currParent !== par.title && !(indexOf.call(par, "hidden") >= 0)) {
          alsoParents.push(par);
        }
      }
      if (alsoParents.length) {
        parentTitles = [];
        for (k = 0, len1 = alsoParents.length; k < len1; k++) {
          i = alsoParents[k];
          altName = args.altNames[alsoParents[i].title.toLowerCase()] ? args.altNames[alsoParents[i].title.toLowerCase()] : null;
          parentTitles.push(this.createCatLink(alsoParents[i].title, args.params.replace, altName));
        }
        text += " (" + args.params.alsoIn + " " + parentTitles.join(", ") + ")";
      }
    }
    text += "</small>\n";
    return this.processCategoryEnd(params, args, text);
  };

  UpdateCategoryTree.prototype.processCategoryEnd = function(params, args, text) {
    args.treeText += text;
    params.callArgs = args;
    return this.WM.Cat.recurseTreeContinue(params);
  };

  UpdateCategoryTree.prototype.createCatLink = function(cat, replace, altName) {
    var catName, regExp;
    if (altName) {
      catName = altName;
    } else if (replace) {
      regExp = new RegExp(replace[0], replace[1]);
      catName = cat.substr(9).replace(regExp, replace[2]);
    } else {
      catName = cat.substr(9);
    }
    return "[[:" + cat + "|" + catName + "]]";
  };

  UpdateCategoryTree.prototype.writeToC = function(params) {
    var args, newtext;
    args = params.callArgs;
    args.treeText = "\n" + args.treeText;
    newtext = Str.overwriteBetween(args.source, args.treeText, args.startId, args.endId);
    if (newtext !== args.source) {
      return this.WM.MW.callAPIPost({
        action: "edit",
        bot: "1",
        minor: "1",
        title: args.params.page,
        summary: args.summary,
        text: newtext,
        basetimestamp: args.timestamp,
        token: args.edittoken
      }, null, this.checkWrite, args, null);
    } else {
      this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' is already up to date');
      if (args.callNext) {
        return args.callNext();
      }
    }
  };

  UpdateCategoryTree.prototype.checkWrite = function(res, args) {
    if (res.edit && res.edit.result === 'Success') {
      this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' correctly updated');
      if (args.callNext) {
        return args.callNext();
      }
    } else {
      return this.WM.Log.logError(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' has not been updated!\n' + res['error']['info'] + " (" + res['error']['code'] + ")");
    }
  };

  return UpdateCategoryTree;

})();
