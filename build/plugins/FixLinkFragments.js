// Generated by CoffeeScript 1.12.7
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

module.exports.FixLinkFragments = (function() {
  FixLinkFragments.REQUIRES_GM = false;

  function FixLinkFragments(WM) {
    this.WM = WM;
    this.mainEnd = bind(this.mainEnd, this);
    this.mainContinue = bind(this.mainContinue, this);
    this.processArchWikiLinkContinue = bind(this.processArchWikiLinkContinue, this);
    this.processArchWikiLink = bind(this.processArchWikiLink, this);
    this.findArchWikiLinks2 = bind(this.findArchWikiLinks2, this);
    this.findArchWikiLinks = bind(this.findArchWikiLinks, this);
    this.fixFragment = bind(this.fixFragment, this);
    this.processLinkContinue = bind(this.processLinkContinue, this);
    this.processLink = bind(this.processLink, this);
  }

  FixLinkFragments.prototype.processLink = function(title, links, index, source, newText, prevId, call, callArgs) {
    var link, params, rawfragment, target;
    if (links[index]) {
      link = links[index];
      rawfragment = link.fragment;
      if (rawfragment) {
        this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(link.link, link.rawLink) + " ...");
        target = (link.namespace ? link.namespace + ":" : "") + link.title;
        if (!this.WM.Parser.compareArticleTitles(target, title)) {
          params = {
            'action': 'parse',
            'prop': 'sections',
            'page': target,
            'redirects': 1
          };
          return this.WM.MW.callAPIGet(params, null, this.processLinkContinue, [link, target, rawfragment, links, index, source, newText, prevId, title, call, callArgs], null);
        } else {
          index++;
          return this.processLink(title, links, index, source, newText, prevId, call, callArgs);
        }
      } else {
        index++;
        return this.processLink(title, links, index, source, newText, prevId, call, callArgs);
      }
    } else {
      newText += source.substr(prevId);
      return call(newText, callArgs);
    }
  };

  FixLinkFragments.prototype.processLinkContinue = function(res, args) {
    var call, callArgs, fixedFragment, i, index, len, link, links, newText, prevId, rawfragment, ref, section, sections, source, target, title;
    link = args[0];
    target = args[1];
    rawfragment = args[2];
    links = args[3];
    index = args[4];
    source = args[5];
    newText = args[6];
    prevId = args[7];
    title = args[8];
    call = args[9];
    callArgs = args[10];
    if (res.parse) {
      sections = [];
      ref = res.parse.sections;
      for (i = 0, len = ref.length; i < len; i++) {
        section = ref[i];
        sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
      }
      fixedFragment = this.fixFragment(rawfragment, sections);
      newText += source.substring(prevId, link.index);
      if (fixedFragment === true) {
        newText += link.rawLink;
      } else if (fixedFragment) {
        newText += "[[" + target + "#" + fixedFragment + (link.anchor ? "|" + link.anchor : "") + "]]";
      } else {
        this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link.link, link.rawLink));
        newText += link.rawLink;
      }
      prevId = link.index + link.length;
    }
    index++;
    return this.processLink(title, links, index, source, newText, prevId, call, callArgs);
  };

  FixLinkFragments.prototype.fixFragment = function(rawfragment, sections) {
    var dotFragment, dotSection, fragment, i, len, section;
    fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
    if (sections.indexOf(fragment) < 0) {
      for (i = 0, len = sections.length; i < len; i++) {
        section = sections[i];
        dotSection = this.WM.Parser.dotEncode(section);
        dotFragment = this.WM.Parser.dotEncode(fragment);
        if (dotSection.toLowerCase() === dotFragment.toLowerCase()) {
          if (fragment === dotFragment) {
            return dotSection;
          } else {
            return this.WM.Parser.dotEncodeLinkBreakingFragmentCharacters(section);
          }
        }
      }
      return false;
    } else {
      return true;
    }
  };

  FixLinkFragments.prototype.findArchWikiLinks = function(newText, callArgs) {
    var templates, title;
    templates = this.WM.Parser.findTemplates(newText, 'Related');
    title = this.WM.Editor.getTitle();
    return this.processArchWikiLink(title, templates, 1, 0, newText, "", 0, this.findArchWikiLinks2, callArgs);
  };

  FixLinkFragments.prototype.findArchWikiLinks2 = function(newText, callArgs) {
    var templates, title;
    templates = this.WM.Parser.findTemplates(newText, 'Related2');
    title = this.WM.Editor.getTitle();
    return this.processArchWikiLink(title, templates, 2, 0, newText, "", 0, this.mainEnd, callArgs);
  };

  FixLinkFragments.prototype.processArchWikiLink = function(title, templates, expectedArgs, index, source, newText, prevId, call, callArgs) {
    var args, fragId, link, params, rawfragment, rawtarget, target, template;
    if (templates[index]) {
      template = templates[index];
      args = template["arguments"];
      if (args.length === expectedArgs) {
        link = args[0].value;
        fragId = link.indexOf('#');
        if (fragId > -1) {
          rawtarget = link.substring(0, fragId);
          target = this.WM.Parser.squashContiguousWhitespace(rawtarget).trim();
          rawfragment = link.substr(fragId + 1);
          if (rawfragment) {
            if (!this.WM.Parser.compareArticleTitles(target, title)) {
              this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(link, template.rawTransclusion) + " ...");
              params = {
                'action': 'parse',
                'prop': 'sections',
                'page': target,
                'redirects': 1
              };
              return this.WM.MW.callAPIGet(params, null, this.processArchWikiLinkContinue, [template, target, rawfragment, templates, expectedArgs, index, source, newText, prevId, title, call, callArgs], null);
            } else {
              index++;
              return this.processArchWikiLink(title, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
            }
          } else {
            index++;
            return this.processArchWikiLink(title, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
          }
        } else {
          index++;
          return this.processArchWikiLink(title, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
        }
      } else {
        this.WM.Log.logWarning("Template:" + template.title + " must have " + expectedArgs + " and only " + expectedArgs + (expectedArgs > 1 ? " arguments: " : " argument: ") + template.rawTransclusion);
        index++;
        return this.processArchWikiLink(title, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
      }
    } else {
      newText += source.substr(prevId);
      return call(newText, callArgs);
    }
  };

  FixLinkFragments.prototype.processArchWikiLinkContinue = function(res, args) {
    var anchor, call, callArgs, expectedArgs, fixedFragment, i, index, len, newText, prevId, rawfragment, ref, section, sections, source, target, template, templates, title;
    template = args[0];
    target = args[1];
    rawfragment = args[2];
    templates = args[3];
    expectedArgs = args[4];
    index = args[5];
    source = args[6];
    newText = args[7];
    prevId = args[8];
    title = args[9];
    call = args[10];
    callArgs = args[11];
    if (res.parse) {
      sections = [];
      ref = res.parse.sections;
      for (i = 0, len = ref.length; i < len; i++) {
        section = ref[i];
        sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
      }
      fixedFragment = this.fixFragment(rawfragment, sections);
      newText += source.substring(prevId, template.index);
      if (fixedFragment === true) {
        newText += template.rawTransclusion;
      } else if (fixedFragment) {
        anchor = template["arguments"][1] ? "|" + template["arguments"][1].value : "";
        newText += "{{" + template.title + "|" + target + "#" + fixedFragment + anchor + "}}";
      } else {
        this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(target, template.rawTransclusion));
        newText += template.rawTransclusion;
      }
      prevId = template.index + template.length;
    }
    index++;
    return this.processArchWikiLink(title, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
  };

  FixLinkFragments.prototype.main = function(args, callNext) {
    var links, source, title;
    source = this.WM.Editor.readSource();
    this.WM.Log.logInfo("Fixing links to sections of other articles ...");
    links = this.WM.Parser.findInternalLinks(source, null, null);
    title = this.WM.Editor.getTitle();
    return this.processLink(title, links, 0, source, "", 0, this.mainContinue, callNext);
  };

  FixLinkFragments.prototype.mainContinue = function(newText, callNext) {
    var templates;
    if (location.hostname === 'wiki.archlinux.org') {
      return templates = this.findArchWikiLinks(newText, callNext);
    } else {
      return this.mainEnd(newText, callNext);
    }
  };

  FixLinkFragments.prototype.mainEnd = function(newText, callNext) {
    var source;
    source = this.WM.Editor.readSource();
    if (newText !== source) {
      this.WM.Editor.writeSource(newText);
      this.WM.Log.logInfo("Replaced links to sections of other articles");
    } else {
      this.WM.Log.logInfo("No fixable links to sections of other articles " + "found");
    }
    if (callNext) {
      return callNext();
    }
  };

  return FixLinkFragments;

})();
