// Generated by CoffeeScript 1.12.2
var CSS,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

CSS = require('../../lib.js.generic/dist/CSS');

module.exports.FixBacklinkFragments = (function() {
  var readTarget;

  FixBacklinkFragments.REQUIRES_GM = false;

  function FixBacklinkFragments(WM) {
    this.WM = WM;
    this.mainAutoEnd = bind(this.mainAutoEnd, this);
    this.mainAutoWrite = bind(this.mainAutoWrite, this);
    this.mainAutoRead = bind(this.mainAutoRead, this);
    this.mainAutoFindSections = bind(this.mainAutoFindSections, this);
    this.fixFragment = bind(this.fixFragment, this);
    this.fixArchWikiLink = bind(this.fixArchWikiLink, this);
    this.fixArchWikiLinks = bind(this.fixArchWikiLinks, this);
    this.fixLinks = bind(this.fixLinks, this);
    this.makeBotUI = bind(this.makeBotUI, this);
  }

  FixBacklinkFragments.prototype.makeBotUI = function(args) {
    var divMain, label, target;
    CSS.addStyleElement("#WikiMonkey-FixBacklinkFragments " + "input[type='text'] {margin-left:0.33em;}");
    divMain = document.createElement('div');
    divMain.id = "WikiMonkey-FixBacklinkFragments";
    label = document.createElement('span');
    label.innerHTML = 'Target page:';
    divMain.appendChild(label);
    target = document.createElement('input');
    target.setAttribute('type', 'text');
    target.id = "WikiMonkey-FixBacklinkFragments-Target";
    if (this.WM.WhatLinksHere.isWhatLinksHerePage()) {
      target.value = this.WM.WhatLinksHere.getTitle();
    }
    divMain.appendChild(target);
    return divMain;
  };

  readTarget = function() {
    return document.getElementById("WikiMonkey-FixBacklinkFragments-Target").value;
  };

  FixBacklinkFragments.prototype.fixLinks = function(source, target, sections) {
    var fixedFragment, i, len, link, links, newText, newlink, oldlink, prevId, rawfragment;
    links = this.WM.Parser.findInternalLinks(source, null, target);
    newText = "";
    prevId = 0;
    for (i = 0, len = links.length; i < len; i++) {
      link = links[i];
      newText += source.substring(prevId, link.index);
      newlink = link.rawLink;
      rawfragment = link.fragment;
      if (rawfragment) {
        fixedFragment = this.fixFragment(rawfragment, sections);
        if (fixedFragment === true) {
          null;
        } else if (fixedFragment) {
          oldlink = newlink;
          newlink = "[[" + target + "#" + fixedFragment + (link.anchor ? "|" + link.anchor : "") + "]]";
          this.WM.Log.logInfo("Fixed broken link fragment: " + oldlink + " -> " + this.WM.Log.linkToWikiPage(link.link, newlink));
        } else {
          this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link.link, newlink));
        }
      }
      newText += newlink;
      prevId = link.index + link.length;
    }
    newText += source.substr(prevId);
    if (location.hostname === 'wiki.archlinux.org') {
      newText = this.fixArchWikiLinks(newText, target, sections);
    }
    return newText;
  };

  FixBacklinkFragments.prototype.fixArchWikiLinks = function(source, target, sections) {
    var i, j, len, len1, link, link2, links, links2, newText1, newText2, prevId;
    links = this.WM.Parser.findTemplates(source, 'Related');
    newText1 = "";
    prevId = 0;
    for (i = 0, len = links.length; i < len; i++) {
      link = links[i];
      newText1 += source.substring(prevId, link.index);
      newText1 += this.fixArchWikiLink(target, sections, link, 1);
      prevId = link.index + link.length;
    }
    newText1 += source.substr(prevId);
    links2 = this.WM.Parser.findTemplates(newText1, 'Related2');
    newText2 = "";
    prevId = 0;
    for (j = 0, len1 = links2.length; j < len1; j++) {
      link2 = links2[j];
      newText2 += newText1.substring(prevId, link2.index);
      newText2 += this.fixArchWikiLink(target, sections, link2, 2);
      prevId = link2.index + link2.length;
    }
    newText2 += newText1.substr(prevId);
    return newText2;
  };

  FixBacklinkFragments.prototype.fixArchWikiLink = function(target, sections, template, expectedArgs) {
    var anchor, args, fixedFragment, fragId, link, ltitle, newlink, rawfragment;
    args = template["arguments"];
    if (args.length === expectedArgs) {
      link = args[0].value;
      fragId = link.indexOf('#');
      if (fragId > -1) {
        ltitle = link.substring(0, fragId);
        if (this.WM.Parser.compareArticleTitles(ltitle, target)) {
          rawfragment = link.substr(fragId + 1);
          fixedFragment = this.fixFragment(rawfragment, sections);
          if (fixedFragment === true) {
            null;
          } else if (fixedFragment) {
            anchor = args[1] ? "|" + args[1].value : "";
            newlink = "{{" + template.title + "|" + target + "#" + fixedFragment + anchor + "}}";
            this.WM.Log.logInfo("Fixed broken link fragment: " + template.rawTransclusion + " -> " + this.WM.Log.linkToWikiPage(link, newlink));
            return newlink;
          } else {
            this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link, template.rawTransclusion));
          }
        }
      }
    } else {
      this.WM.Log.logWarning("Template:" + template.title + " must have " + expectedArgs + " and only " + expectedArgs + (expectedArgs > 1 ? " arguments: " : " argument: ") + template.rawTransclusion);
    }
    return template.rawTransclusion;
  };

  FixBacklinkFragments.prototype.fixFragment = function(rawfragment, sections) {
    var fragment, i, len, section;
    if (rawfragment) {
      fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
      if (sections.indexOf(fragment) < 0) {
        for (i = 0, len = sections.length; i < len; i++) {
          section = sections[i];
          if (section.toLowerCase() === fragment.toLowerCase()) {
            return section;
          }
        }
        return false;
      } else {
        return true;
      }
    } else {
      return true;
    }
  };

  FixBacklinkFragments.prototype.mainAuto = function(args, title, callBot, chainArgs) {
    var params, summary, target;
    summary = args;
    target = readTarget();
    this.WM.Log.logHidden("Target page: " + target);
    if (target) {
      if (chainArgs === null) {
        params = {
          'action': 'parse',
          'prop': 'sections',
          'page': target,
          'redirects': 1
        };
        this.WM.Log.logWarning("If some articles in the list are linking to the target article through a redirect, you should process the backlinks of that redirect page separately through its Special:WhatLinksHere page, as this plugin can only fix links that exactly match the title of the target article.\nIn order to save time you are advised to hide the redirects in the page lists that allow to do so.");
        return this.WM.MW.callAPIGet(params, null, this.mainAutoFindSections, [title, target, summary, callBot], null);
      } else {
        return this.mainAutoRead(target, chainArgs, title, summary, callBot);
      }
    } else {
      this.WM.Log.logError('The target page cannot be empty');
      return callBot(false, null);
    }
  };

  FixBacklinkFragments.prototype.mainAutoFindSections = function(res, args) {
    var callBot, i, len, ref, section, sections, summary, target, title;
    title = args[0];
    target = args[1];
    summary = args[2];
    callBot = args[3];
    sections = [];
    if (res.parse) {
      ref = res.parse.sections;
      for (i = 0, len = ref.length; i < len; i++) {
        section = ref[i];
        sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
      }
      return this.mainAutoRead(target, sections, title, summary, callBot);
    } else {
      this.WM.Log.logError("The set target page, " + target + ", seems not to exist");
      if (res.error) {
        return callBot(res.error.code, sections);
      } else {
        return callBot(false, sections);
      }
    }
  };

  FixBacklinkFragments.prototype.mainAutoRead = function(target, sections, title, summary, callBot) {
    return this.WM.MW.callQueryEdit(title, this.mainAutoWrite, [target, summary, callBot, sections]);
  };

  FixBacklinkFragments.prototype.mainAutoWrite = function(title, source, timestamp, edittoken, args) {
    var callBot, newtext, sections, summary, target;
    target = args[0];
    summary = args[1];
    callBot = args[2];
    sections = args[3];
    newtext = this.fixLinks(source, target, sections);
    if (newtext !== source) {
      return this.WM.MW.callAPIPost({
        action: "edit",
        bot: "1",
        title: title,
        summary: summary,
        text: newtext,
        basetimestamp: timestamp,
        token: edittoken
      }, null, this.mainAutoEnd, [callBot, sections], null);
    } else {
      return callBot(0, sections);
    }
  };

  FixBacklinkFragments.prototype.mainAutoEnd = function(res, args) {
    var callBot, sections;
    callBot = args[0];
    sections = args[1];
    if (res.edit && res.edit.result === 'Success') {
      return callBot(1, sections);
    } else if (res.error) {
      this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
      return callBot(res.error.code, sections);
    } else {
      return callBot(false, sections);
    }
  };

  return FixBacklinkFragments;

})();
