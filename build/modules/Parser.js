// Generated by CoffeeScript 1.11.1
var RegEx, Str;

RegEx = require('../../lib.js.generic/dist/RegEx');

Str = require('../../lib.js.generic/dist/Str');

module.exports.Parser = (function() {
  var prepareRegexpWhitespace, prepareTitleCasing;

  function Parser(WM) {
    this.WM = WM;
  }

  Parser.prototype.squashContiguousWhitespace = function(title) {
    return title.replace(/[_ ]+/g, " ");
  };

  Parser.prototype.neutralizeNowikiTags = function(source) {
    var CLOSELENGTH, OPENLENGTH, i, len, maskLength, maskString, maskedText, prevId, tag, tags;
    OPENLENGTH = 8;
    CLOSELENGTH = 9;
    tags = Str.findSimpleEnclosures(source, /<nowiki>/i, OPENLENGTH, /<\/nowiki>/i, CLOSELENGTH);
    maskedText = "";
    prevId = 0;
    for (i = 0, len = tags.length; i < len; i++) {
      tag = tags[i];
      if (tag[1]) {
        maskLength = tag[1] - tag[0] + CLOSELENGTH;
        maskString = Str.padRight("", "x", maskLength);
        maskedText += source.substring(prevId, tag[0]) + maskString;
        prevId = tag[1] + CLOSELENGTH;
        continue;
      } else {
        maskLength = source.substr(tag[0]).length;
        maskString = Str.padRight("", "x", maskLength);
        maskedText += source.substring(prevId, tag[0]) + maskString;
        prevId = source.length;
        break;
      }
    }
    maskedText += source.substring(prevId);
    return maskedText;
  };

  Parser.prototype.dotEncode = function(text) {
    return encodeURIComponent(text).replace(/%/g, ".");
  };

  Parser.prototype.dotEncodeLinkBreakingFragmentCharacters = function(fragment) {
    fragment = fragment.replace(/\[/g, ".5B");
    fragment = fragment.replace(/\]/g, ".5D");
    fragment = fragment.replace(/\{/g, ".7B");
    fragment = fragment.replace(/\}/g, ".7D");
    fragment = fragment.replace(/\|/g, ".7C");
    return fragment;
  };

  prepareRegexpWhitespace = function(title) {
    return title.replace(/[_ ]+/g, "[_ ]+");
  };

  prepareTitleCasing = function(pattern) {
    var fcLower, fcUpper, firstChar;
    firstChar = pattern.charAt(0);
    fcUpper = firstChar.toUpperCase();
    fcLower = firstChar.toLowerCase();
    if (fcUpper !== fcLower) {
      pattern = "[" + fcUpper + fcLower + "]" + pattern.substr(1);
    }
    return pattern;
  };

  Parser.prototype.compareArticleTitles = function(title1, title2) {
    var t1, t2;
    t1 = prepareTitleCasing(this.squashContiguousWhitespace(title1).trim());
    t2 = prepareTitleCasing(this.squashContiguousWhitespace(title2).trim());
    return t1 === t2;
  };

  Parser.prototype.findBehaviorSwitches = function(source, word) {
    var regExp;
    source = this.neutralizeNowikiTags(source);
    regExp;
    if (word) {
      regExp = new RegExp("__" + RegEx.escapePattern(word) + "__", "gi");
    } else {
      regExp = new RegExp("__(TOC|NOTOC|FORCETOC|NOEDITSECTION|" + "NEWSECTIONLINK|NONEWSECTIONLINK|NOGALLERY|HIDDENCAT|" + "NOCONTENTCONVERT|NOCC|NOTITLECONVERT|NOTC|INDEX|" + "NOINDEX|STATICREDIRECT|START|END)__", "gi");
    }
    return RegEx.matchAll(source, regExp);
  };

  Parser.prototype.findLinksEngine = function(source, titlePattern, specialOnly, caseSensitive) {
    var dbrace, dbraces, flags, i, inText, len, links, maskedText, match, nSource, nText, push, regExp, special;
    flags = caseSensitive ? "" : "i";
    special = specialOnly ? "(?:[ _]+:)?[ _]*" : "(?:\\:?[ _]*){0,2}";
    regExp = new RegExp("^" + special + "(" + titlePattern + ")" + "[ _]*(?:\\|[_\\s]*([\\s\\S]+?)[_\\s]*)?[_\\s]*$", flags);
    nSource = this.neutralizeNowikiTags(source);
    links = [];
    dbraces = Str.findInnermostEnclosures(nSource, "[[", "]]");
    for (i = 0, len = dbraces.length; i < len; i++) {
      dbrace = dbraces[i];
      inText = source.substring(dbrace[0] + 2, dbrace[1]);
      match = regExp.exec(inText);
      if (match) {
        push = true;
        if (match[6]) {
          nText = this.neutralizeNowikiTags(match[6]);
          maskedText = Str.findNestedEnclosures(nText, "{{", "}}", "x")[1];
          if (maskedText.search(/(\{\{|\}\})/) > -1) {
            this.WM.Log.logWarning("[[" + match[0] + "]] seems to contain part of a template, and the resulting behaviour cannot be predicted by this function, so the link will be ignored altogether");
            push = false;
          }
        }
        if (push) {
          links.push({
            "rawLink": "[[" + match[0] + "]]",
            "link": match[1],
            "rawTitle": match[2],
            "namespace": match[3],
            "title": match[4],
            "fragment": match[5],
            "anchor": match[6],
            "index": dbrace[0],
            "length": dbrace[1] + 2 - dbrace[0]
          });
        }
      }
    }
    return links;
  };

  Parser.prototype.findSectionLinks = function(source) {
    var fragmentChars, titlePattern;
    fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
    titlePattern = "(()())#(" + fragmentChars + ")";
    return this.findLinksEngine(source, titlePattern, false, true);
  };

  Parser.prototype.findInternalLinks = function(source, namespace, title) {
    var caseSensitive, fragmentChars, namespaceChars, rens, retitle, titleChars, titlePattern;
    namespaceChars = "[^\\n\\{\\}\\[\\]\\|\\:\\#]+?";
    titleChars = "[^\\n\\{\\}\\[\\]\\|\\#]+?";
    fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
    if (namespace) {
      rens = prepareRegexpWhitespace(RegEx.escapePattern(namespace));
      if (title) {
        retitle = prepareRegexpWhitespace(RegEx.escapePattern(title));
        titlePattern = "((" + rens + ")[ _]*:[ _]*" + "(" + retitle + "))" + "(?:[ _]*#(" + fragmentChars + "))?";
        caseSensitive = true;
      } else {
        titlePattern = "((" + rens + ")[ _]*:[ _]*" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";
        caseSensitive = false;
      }
    } else if (title) {
      retitle = prepareRegexpWhitespace(RegEx.escapePattern(title));
      titlePattern = "(()(" + retitle + "))" + "(?:[ _]*#(" + fragmentChars + "))?";
      caseSensitive = true;
    } else {
      titlePattern = "((?:(" + namespaceChars + ")[ _]*:[ _]*)?" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";
      caseSensitive = true;
    }
    return this.findLinksEngine(source, titlePattern, false, caseSensitive);
  };

  Parser.prototype.findInterwikiLinks = function(source, wiki) {
    return this.findInternalLinks(source, wiki);
  };

  Parser.prototype.findSpecialLinks = function(source, pattern) {
    var fragmentChars, titleChars, titlePattern;
    titleChars = "[^\\n\\{\\}\\[\\]\\|\\#]+?";
    fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
    titlePattern = "((" + pattern + ")[ _]*:[ _]*" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";
    return this.findLinksEngine(source, titlePattern, true, false);
  };

  Parser.prototype.findCategories = function(source) {
    return this.findSpecialLinks(source, "Category");
  };

  Parser.prototype.findInterlanguageLinks = function(source, language) {
    return this.findSpecialLinks(source, RegEx.escapePattern(language));
  };

  Parser.prototype.findVariables = function(source, variable) {
    var pattern;
    pattern = RegEx.escapePattern(variable);
    return this.findVariablesPattern(source, pattern);
  };

  Parser.prototype.findVariablesPattern = function(source, pattern) {
    var dbracket, dbrackets, i, inText, len, match, nSource, regExp, results;
    nSource = this.neutralizeNowikiTags(source);
    results = [];
    dbrackets = Str.findNestedEnclosures(nSource, "{{", "}}", "x")[0];
    for (i = 0, len = dbrackets.length; i < len; i++) {
      dbracket = dbrackets[i];
      inText = source.substring(dbracket[0] + 2, dbracket[1]);
      regExp = new RegExp("^\\s*(" + pattern + ")" + "(?:\\:\\s*([\\s\\S]*?))?\\s*$", "");
      match = regExp.exec(inText);
      if (match) {
        results.push({
          "rawVariable": "{{" + match[0] + "}}",
          "name": match[1],
          "value": match[2],
          "index": dbracket[0],
          "length": dbracket[1] + 2 - dbracket[0]
        });
      }
    }
    return results;
  };

  Parser.prototype.findTransclusionsEngine = function(source, pattern, templatesOnly) {
    var argIndex, dbracket, dbrackets, i, inText, len, match, nSource, regExp, transclusions;
    regExp = new RegExp("^(\\s*" + (templatesOnly ? "" : ":?") + "[_ ]*(" + pattern + ")[_ ]*\\s*)" + "(?:\\|([\\s\\S]*))?$", "");
    nSource = this.neutralizeNowikiTags(source);
    transclusions = [];
    dbrackets = Str.findNestedEnclosures(nSource, "{{", "}}", "x")[0];
    for (i = 0, len = dbrackets.length; i < len; i++) {
      dbracket = dbrackets[i];
      inText = source.substring(dbracket[0] + 2, dbracket[1]);
      match = regExp.exec(inText);
      if (match) {
        argIndex = dbracket[0] + match[1].length + 3;
        transclusions.push({
          "rawTransclusion": "{{" + match[0] + "}}",
          "title": match[2],
          "index": dbracket[0],
          "length": dbracket[1] - dbracket[0] + 2,
          "arguments": this.findTransclusionArguments(match, argIndex)
        });
      }
    }
    return transclusions;
  };

  Parser.prototype.findTransclusionArguments = function(match, argIndex) {
    var argL, args, argument, eqIndex, i, key, keyIndex, keyMatches, len, mArgs, mArgument, maskedArgs, nArgs, rawArguments, rawKey, reKey, relIndex, value, valueIndex;
    rawArguments = match[3];
    args = [];
    if (rawArguments) {
      nArgs = this.neutralizeNowikiTags(rawArguments);
      maskedArgs = Str.findNestedEnclosures(nArgs, "[[", "]]", "x")[1];
      maskedArgs = Str.findNestedEnclosures(maskedArgs, "{{", "}}", "x")[1];
      if (maskedArgs.search(/(\{\{|\}\}|\[\[|\]\])/) > -1) {
        this.WM.Log.logWarning("{{" + match[0] + "}} seems to contain part of a link or template, and the resulting behaviour cannot be predicted by this function, so the whole template will be ignored altogether");
      } else {
        mArgs = maskedArgs.split("|");
        relIndex = 0;
        for (i = 0, len = mArgs.length; i < len; i++) {
          mArgument = mArgs[i];
          argL = mArgument.length;
          argument = rawArguments.substr(relIndex, argL);
          eqIndex = mArgument.indexOf("=");
          if (eqIndex > 0) {
            rawKey = argument.substring(0, eqIndex);
            reKey = /^(\s*)(.+?)\s*$/;
            keyMatches = reKey.exec(rawKey);
            key = keyMatches[2];
            keyIndex = argIndex + (keyMatches[1] ? keyMatches[1].length : 0);
            value = argument.substr(eqIndex + 1);
            valueIndex = argIndex + keyMatches[0].length + 1;
          } else {
            key = null;
            keyIndex = null;
            value = argument;
            valueIndex = argIndex;
          }
          args.push({
            key: key,
            key_index: keyIndex,
            value: value,
            value_index: valueIndex
          });
          relIndex += argL + 1;
        }
      }
    }
    return args;
  };

  Parser.prototype.findTemplates = function(source, template) {
    var pattern;
    if (template) {
      pattern = RegEx.escapePattern(template);
      pattern = prepareRegexpWhitespace(pattern);
      pattern = prepareTitleCasing(pattern);
    } else {
      pattern = "[^\\n\\{\\}\\[\\]\\||\\#]+?";
    }
    return this.findTemplatesPattern(source, pattern);
  };

  Parser.prototype.findTemplatesPattern = function(source, pattern) {
    return this.findTransclusionsEngine(source, pattern, true);
  };

  Parser.prototype.findTransclusions = function(source, namespace, title) {
    var namespacePattern, pattern, titleChars, titlePattern;
    titleChars = "[^\\n\\{\\}\\[\\]\\||\\#]+?";
    if (namespace) {
      namespacePattern = RegEx.escapePattern(namespace);
      namespacePattern = prepareRegexpWhitespace(namespacePattern);
      namespacePattern = prepareTitleCasing(namespacePattern);
    }
    if (title) {
      titlePattern = RegEx.escapePattern(title);
      titlePattern = prepareRegexpWhitespace(titlePattern);
      titlePattern = prepareTitleCasing(titlePattern);
    }
    if (namespacePattern && titlePattern) {
      pattern = namespacePattern + "[ _]*:[ _]*" + titlePattern;
    } else if (!namespacePattern && titlePattern) {
      pattern = titlePattern;
    } else if (namespacePattern && !titlePattern) {
      pattern = namespacePattern + "[ _]*:" + titleChars;
    } else {
      pattern = titleChars;
    }
    return this.findTransclusionsEngine(source, pattern, false);
  };

  Parser.prototype.findSectionHeadings = function(source) {
    var L0, L1, MAXLEVEL, cleanheading, end, heading, i, len, level, line, match, maxTocLevel, minLevel, pLevel, prevLevels, rawheading, regExp, sections, start, tocLevel, tocPeer;
    MAXLEVEL = 6;
    sections = [];
    minLevel = MAXLEVEL;
    maxTocLevel = 0;
    tocLevel = 1;
    regExp = /^(\=+([ _]*(.+?)[ _]*)\=+)[ \t]*$/gm;
    while (true) {
      match = regExp.exec(source);
      if (match) {
        L0 = match[0].length;
        line = match[1];
        rawheading = match[2];
        heading = match[3];
        cleanheading = this.squashContiguousWhitespace(heading);
        L1 = line.length;
        level = 1;
        start = "=";
        end = "=";
        while (true) {
          start = line.substr(level, 1);
          end = line.substr(L1 - level - 1, 1);
          if (L1 - level * 2 > 2 && start === "=" && end === "=") {
            level++;
          } else {
            if (level > MAXLEVEL) {
              level = MAXLEVEL;
            } else if (level < minLevel) {
              minLevel = level;
            }
            break;
          }
        }
        if (level === minLevel) {
          tocLevel = 1;
          prevLevels = {};
          prevLevels[level] = 1;
          prevLevels.relMax = level;
          if (maxTocLevel === 0) {
            maxTocLevel = tocLevel;
          }
        } else if (level > prevLevels.relMax) {
          tocLevel++;
          prevLevels[level] = tocLevel;
          prevLevels.relMax = level;
          if (tocLevel > maxTocLevel) {
            maxTocLevel = tocLevel;
          }
        } else if (level < prevLevels.relMax) {
          if (prevLevels[level]) {
            tocLevel = prevLevels[level];
          } else {
            tocPeer = prevLevels.relMax;
            for (i = 0, len = prevLevels.length; i < len; i++) {
              pLevel = prevLevels[i];
              if (pLevel > level && pLevel < tocPeer) {
                tocPeer = pLevel;
              }
            }
            tocLevel = prevLevels[tocPeer];
            prevLevels[level] = tocLevel;
          }
          prevLevels.relMax = level;
        }
        sections.push({
          line: line,
          rawheading: rawheading,
          heading: heading,
          cleanheading: cleanheading,
          level: level,
          tocLevel: tocLevel,
          index: regExp.lastIndex - L0,
          length0: L0,
          length1: L1
        });
      } else {
        break;
      }
    }
    if (maxTocLevel === 0) {
      minLevel = 0;
    }
    return {
      sections: sections,
      minLevel: minLevel,
      maxTocLevel: maxTocLevel
    };
  };

  return Parser;

})();
